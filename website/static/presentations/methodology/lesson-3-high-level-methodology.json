{
  "metadata": {
    "title": "High-Level Methodology: Research, Plan, Execute, Validate",
    "lessonId": "lesson-3",
    "estimatedDuration": "45-60 minutes",
    "learningObjectives": [
      "Shift from craftsman to orchestrator",
      "Apply four-phase systematic workflow",
      "Ground agents with research context",
      "Validate results against mental models"
    ]
  },
  "slides": [
    {
      "type": "title",
      "title": "High-Level Methodology",
      "subtitle": "The Operator's Workflow: Research → Plan → Execute → Validate",
      "content": [],
      "speakerNotes": {
        "talkingPoints": "This lesson reframes your role when working with AI agents. You're no longer writing all the code yourself—you're orchestrating a system. The workflow we're covering today is the strategic foundation that makes this work.",
        "timing": "1 minute",
        "discussion": "Before we start, think about a task you've delegated recently. What made you trust the outcome?",
        "context": "The psychological shift from implementer to operator is the hardest part of working with agents effectively.",
        "transition": "Let's start by understanding what this role shift really means."
      }
    },
    {
      "type": "concept",
      "title": "The Operator Mindset: Role Shift",
      "content": [
        "Traditional: Write → Test → Review → Debug",
        "Operator: Understand → Research → Plan → Validate",
        "Cognitive load shifts from syntax to architecture",
        "Your value moves up the stack"
      ],
      "speakerNotes": {
        "talkingPoints": "You've spent your career mastering details. Writing clean code, spotting subtle bugs, owning every line you ship. AI agents force a different model: you can't read and mentally own 2,000 lines the way you owned 200. The shift is psychological—from craftsman to orchestrator. Your value isn't in typing code anymore; it's in understanding systems, articulating requirements, and validating outcomes.",
        "timing": "3-4 minutes",
        "discussion": "Ask: What feels riskiest about letting go of code review? What patterns have you built trust in?",
        "context": "Senior engineers often struggle most with this shift because their confidence is built on deep technical ownership. Reframe: orchestration IS ownership.",
        "transition": "But you don't let go completely. You shift what you focus on."
      }
    },
    {
      "type": "concept",
      "title": "What You Stop vs. What You Focus On",
      "content": [
        "Stop: Reading every line, debugging syntax, implementation details",
        "Focus: Architectural patterns, constraints, integration points",
        "Properly grounded agents produce consistent, readable code",
        "Your mental model becomes your validation blueprint"
      ],
      "speakerNotes": {
        "talkingPoints": "Here's the counterintuitive reality: AI-generated code is often easier to read than hand-written code. LLMs follow patterns with mechanical precision. When you provide quality patterns and clear constraints, they replicate perfectly across thousands of lines. Your responsibility shifts from ensuring every detail is correct to ensuring the patterns themselves are correct. Your mental model—your understanding of how components fit together—becomes your most valuable tool.",
        "timing": "2-3 minutes",
        "discussion": "Can you think of a pattern you've seen implemented inconsistently across a codebase? How would agents help?",
        "context": "Show an example: 50 files generated by an agent following one pattern vs. hand-written code with 10 different interpretations of the same pattern.",
        "transition": "This is only possible if you're strategic about what you communicate to the agent."
      }
    },
    {
      "type": "visual",
      "title": "The Four-Phase Workflow",
      "component": "WorkflowCircle",
      "caption": "Systematic workflow ensures quality without reading every line",
      "speakerNotes": {
        "talkingPoints": "This is the framework for every significant interaction with an agent. Each phase has a distinct purpose. Skip any one, and your failure rate increases dramatically. Research grounds the agent in your context. Plan ensures you're clear on what you want before execution starts. Execute is where you choose supervision vs. autonomy. Validate is where you decide: iterate or regenerate?",
        "timing": "2 minutes",
        "discussion": "Which phase do you think you naturally skip?",
        "context": "This workflow applies whether you're using Claude, Copilot, Cursor, or any AI coding assistant. It's about systematic thinking, not tool specifics.",
        "transition": "Let's walk through each phase in detail, starting with research."
      }
    },
    {
      "type": "concept",
      "title": "Phase 1: Research (Grounding)",
      "content": [
        "Agents need both codebase context and domain knowledge",
        "Code research: ChunkHound for architectural patterns",
        "Domain research: ArguSeek for best practices and APIs",
        "Grounding prevents hallucinations and inconsistency"
      ],
      "speakerNotes": {
        "talkingPoints": "Grounding is the bridge between the general knowledge in the model and your specific real-world context. Without it, agents invent patterns, miss existing implementations, and hallucinate APIs. Code research answers architectural questions: How is authentication handled? What's the error pattern? Domain research pulls information from documentation, frameworks, and best practices. Both tools reduce the work agents do guessing.",
        "timing": "3-4 minutes",
        "discussion": "What's the most common hallucination you've seen from AI? How would grounding have prevented it?",
        "context": "Share an example: agent inventing a custom auth solution because it didn't know about the existing auth middleware in the codebase.",
        "transition": "With research complete, you move to planning—deciding the architectural approach."
      }
    },
    {
      "type": "visual",
      "title": "Planning Strategies: Explore vs. Execute",
      "component": "PlanningStrategyComparison",
      "caption": "Choose exploration or precision based on solution clarity",
      "speakerNotes": {
        "talkingPoints": "Planning isn't one approach—it's a strategic choice. Exploration planning is for uncertain solution spaces: you frame the problem and steer the agent to research, explore alternatives, and iterate with you. This is slower but discovers better solutions. Exact planning is for known solutions: you be directive and specific about requirements, patterns, constraints, and acceptance criteria. This is faster but requires upfront clarity.",
        "timing": "3-4 minutes",
        "discussion": "When would you use exploration? When would you use exact planning?",
        "context": "Example: Adding authentication (might need exploration to choose OAuth vs. JWT). Refactoring error handling to a known pattern (exact planning).",
        "transition": "Let's look at what exact planning looks like in practice."
      }
    },
    {
      "type": "code",
      "title": "Exact Planning: Clear, Directive Specification",
      "language": "text",
      "code": "Add JWT authentication to Express middleware\nwith these patterns:\n\nMiddleware: src/middleware/auth.ts\nError handling: throw 401 Unauthorized\nEdge cases:\n  - Malformed tokens\n  - Expired tokens\n  - Missing Authorization header\n\nAcceptance: Tests pass, no changes to routes",
      "caption": "Exact planning defines specific integration points and success criteria",
      "speakerNotes": {
        "talkingPoints": "When you know the solution, be directive. Define the task with specificity, specify integration points and patterns, provide explicit constraints, list edge cases, and define clear acceptance criteria. The agent executes along a predetermined path. This approach is faster and more cost-effective.",
        "timing": "2-3 minutes",
        "discussion": "Compare this to vague planning. What's missing if you just said 'add authentication'?",
        "context": "The specificity here—naming the file, identifying which edge cases matter, defining what 'done' looks like—is what makes the agent produce predictable results.",
        "transition": "The flip side: when you're uncertain about the approach."
      }
    },
    {
      "type": "code",
      "title": "Exploration Planning: Discover the Best Approach",
      "language": "text",
      "code": "Research our auth patterns:\n  - How is auth currently handled?\n  - What frameworks are in use?\n  - What are the performance\n    requirements?\n\nExplore trade-offs:\n  - JWT vs. session-based\n  - Centralized vs. distributed\n\nRecommend an approach with\njustification",
      "caption": "Exploration planning frames problems and discovers solutions together",
      "speakerNotes": {
        "talkingPoints": "When the solution space is unclear, don't dictate—frame the problem. Have the agent research your patterns, explore alternatives, and iterate with you. This takes more time and iteration cycles but discovers better solutions and helps you build a mental model before committing.",
        "timing": "2-3 minutes",
        "discussion": "When was the last time you picked the wrong architecture? How would exploration planning have helped?",
        "context": "Exploration is especially valuable for novel problems, major refactors, or when moving to unfamiliar tech.",
        "transition": "Once your plan is solid, execution begins—but there are two very different modes."
      }
    },
    {
      "type": "comparison",
      "title": "Execution Modes: Supervised vs. Autonomous",
      "left": {
        "label": "Supervised Mode",
        "content": [
          "Watch each action as agent works",
          "Review intermediate outputs",
          "Steer when agent drifts",
          "Maximum control, maximum cognitive load",
          "Bottleneck: you can't context-switch"
        ]
      },
      "right": {
        "label": "Autonomous Mode",
        "content": [
          "Fire-and-forget well-defined task",
          "Check results when done",
          "Work on multiple projects simultaneously",
          "Real productivity gain from parallel work",
          "Requires excellent grounding and planning"
        ]
      },
      "speakerNotes": {
        "talkingPoints": "Supervised mode gives you maximum control at the cost of blocking you entirely. You can't work on anything else while watching. Autonomous mode seems risky, but with solid grounding and planning, it works remarkably well. The real productivity gain isn't per-task speed—it's parallel work. Three autonomous agents running while you attend meetings or cook dinner. That's 10x productivity.",
        "timing": "4-5 minutes",
        "discussion": "Which mode do you naturally default to? What would let you trust autonomous more?",
        "context": "Most engineers start supervised to build trust, then transition to autonomous as they get stronger at grounding and planning. This is the right progression.",
        "transition": "The agent finished. Now comes validation—the most critical phase."
      }
    },
    {
      "type": "concept",
      "title": "Phase 4: Validation (The Iteration Decision)",
      "content": [
        "LLMs are probabilistic—first output is rarely perfect",
        "Don't verify perfection; identify what's wrong",
        "Iterate when: Foundation is right, gaps exist",
        "Regenerate when: Architecture fundamentally wrong",
        "Usually easier to fix context than fix code"
      ],
      "speakerNotes": {
        "talkingPoints": "Validation isn't about finding a 100% perfect output—that rarely happens. It's about accurately identifying what's wrong or missing, then making a decision: iterate with fixes or regenerate from scratch? The key insight: it's usually easier to fix your context (the prompt, examples, constraints) than to fix generated code. When something feels fundamentally wrong, regenerate with better context rather than patching the code.",
        "timing": "3-4 minutes",
        "discussion": "Tell me about a time you spent hours fixing code when you should have just written it differently.",
        "context": "This is a mindset shift: treat your inputs as debuggable, not just your outputs.",
        "transition": "How do you validate effectively?"
      }
    },
    {
      "type": "concept",
      "title": "Validation Techniques: Testing Your Code",
      "content": [
        "Run your implementation: be the user, test edge cases",
        "Use the agent to review its own work (Lesson 9)",
        "Create tests as guardrails (Lesson 8)",
        "Run automated checks: build, tests, linters",
        "Validate against your mental model, not every line"
      ],
      "speakerNotes": {
        "talkingPoints": "Nothing beats running your code. Test the happy path, try to break it, check edge cases. Does it handle errors gracefully? Agents are better at finding issues in code than generating perfect code. Have them review their own work. Use tests as guardrails—we'll cover this in Lesson 8. And run your build, tests, and linters. If these pass and behavior matches your plan, ship it. You're not validating by reading every line; you're validating against your mental model.",
        "timing": "3 minutes",
        "discussion": "What's your current validation process? Where do issues slip through?",
        "context": "Share a production bug that would have been caught by this validation approach.",
        "transition": "This workflow isn't linear. Validation often reveals gaps in planning or research."
      }
    },
    {
      "type": "takeaway",
      "title": "Key Takeaways: Operating at Agent Scale",
      "content": [
        "Shift from craftsman to orchestrator—your value is in strategy, not syntax",
        "Grounding and planning determine execution quality more than supervision",
        "Autonomous mode enables true productivity gains through parallel work",
        "Validate your mental model, not every line—trust systematic workflow"
      ],
      "speakerNotes": {
        "talkingPoints": "This workflow is the strategic framework that makes agent-assisted development work. You're not doing the same job faster—you're doing a different job at a different scale. Grounding prevents hallucinations. Planning ensures alignment before execution. Autonomous mode enables parallel work. Validation closes the loop. Master these, and you shift from being a bottleneck to being a force multiplier.",
        "timing": "2 minutes",
        "discussion": "Which takeaway challenges your current practice most?",
        "context": "Emphasize: this is a progression. You'll naturally move through supervised to autonomous as you build confidence.",
        "transition": "The workflow tells you WHAT to do. Lesson 4 teaches you HOW—prompting techniques that make this workflow effective."
      }
    }
  ]
}
