{
  "metadata": {
    "title": "Spec Driven Development",
    "lessonId": "lesson-12-spec-driven-development",
    "estimatedDuration": "30-40 minutes",
    "learningObjectives": [
      "Apply SDD knowledge expansion",
      "Delete specs after implementation",
      "Extract specs from code",
      "Use context as spec"
    ]
  },
  "slides": [
    {
      "type": "title",
      "title": "Spec Driven Development",
      "subtitle": "Single source of truth for agentic workflows",
      "content": [],
      "speakerNotes": {
        "talkingPoints": "This lesson connects DRY principles to how we work with AI agents. We'll explore why specs should be temporary scaffolding, not permanent artifacts—and how your codebase is already the best specification you have.",
        "timing": "1 minute",
        "discussion": "Ask: How many of you have found outdated documentation that contradicted the actual code?",
        "context": "Every team has experienced spec-code drift. This lesson provides a principled solution.",
        "transition": "Let's start with why this matters—the fundamental problem of duplicate knowledge."
      }
    },
    {
      "type": "concept",
      "title": "The Single Source of Truth Problem",
      "content": [
        "DRY isn't just about code—it applies to knowledge",
        "Your codebase encodes requirements, rules, and decisions",
        "When knowledge exists in multiple places, it drifts",
        "Spec says X, code does Y, design mentions Z"
      ],
      "speakerNotes": {
        "talkingPoints": "DRY and Single Source of Truth aren't methodology buzzwords—they're sanity-preserving practices. Your codebase is a knowledge base. Every function, test, and constraint encodes knowledge. When the same information exists in multiple places, bugs follow.",
        "timing": "2-3 minutes",
        "discussion": "Ask students to share examples of spec-code conflicts they've encountered. What was the cost of resolving them?",
        "context": "The session limits example: spec says 5, code implements 10, design says 'configurable'. Three sources, three truths.",
        "transition": "Let's look at how knowledge expands during development—and where the duplication problem comes from."
      }
    },
    {
      "type": "visual",
      "title": "SDLC Knowledge Expansion",
      "component": "KnowledgeExpansionDiamond",
      "caption": "Each development phase expands knowledge from the layer above.",
      "speakerNotes": {
        "talkingPoints": "Traditional development follows a pattern: high-level spec captures the 'what' and 'why', detailed design explores the 'how'—edge cases, constraints, data flows. Code encodes implementation details and optimizations. With AI agents, this happens in hours, not weeks.",
        "timing": "2-3 minutes",
        "discussion": "How does this diamond shape differ from how you've thought about the SDLC before?",
        "context": "The key insight is that each layer is a knowledge expansion of the layer above. The problem comes when all three layers persist after implementation.",
        "transition": "Once implementation is complete, you have a problem—the same knowledge now exists in three places."
      }
    },
    {
      "type": "concept",
      "title": "The Duplicate Knowledge Problem",
      "content": [
        "Post-implementation: spec, design, and code all exist",
        "Which source is correct when they conflict?",
        "This is the Knowledge Cache Anti-Pattern",
        "Future agents find conflicting information"
      ],
      "speakerNotes": {
        "talkingPoints": "Once code passes tests and review, you have knowledge in three places. Saved specifications become stale the moment code changes. Future agents researching your codebase find both the outdated spec and current code, leading to confusion and conflicting implementations.",
        "timing": "2 minutes",
        "discussion": "Why do teams typically keep spec files around after implementation? What are they trying to preserve?",
        "context": "Lesson 5's grounding tools already perform knowledge extraction. ChunkHound processing 50k tokens and returning 3k tokens IS a spec—extracted on-demand from the source of truth.",
        "transition": "The solution is simpler than you might expect—delete the scaffolding when the building is done."
      }
    },
    {
      "type": "comparison",
      "title": "Mainstream SDD vs Correct Approach",
      "left": {
        "label": "Mainstream SDD",
        "content": [
          "Specs as 'permanent living artifacts'",
          "Bidirectional sync spec ↔ code",
          "Two sources of truth",
          "Assumes perfect synchronization"
        ]
      },
      "right": {
        "label": "Correct Approach",
        "content": [
          "Code is the source of truth—period",
          "Specs are temporary scaffolding",
          "Delete specs after implementation",
          "Regenerate on-demand from code"
        ]
      },
      "speakerNotes": {
        "talkingPoints": "Tools like GitHub Spec Kit, Amazon Kiro, and Tessl treat specs as permanent artifacts that evolve alongside code. This violates single source of truth. The moment you have two representations of the same knowledge, you have a consistency problem. We eliminated header files for this reason. We generate API docs from code.",
        "timing": "3-4 minutes",
        "discussion": "Why do you think the 'living spec' model is so appealing despite being fundamentally broken?",
        "context": "In practice, developers modify code directly. The spec-code relationship isn't 'drifting'—it's broken because you've created two sources of truth.",
        "transition": "Let's look at how to extract different spec shapes from the same source code."
      }
    },
    {
      "type": "concept",
      "title": "Grounding Tools as Knowledge Extractors",
      "content": [
        "Same code → different compression targets",
        "\"What does this module do?\" → High-level spec",
        "\"How is auth implemented?\" → Detailed design",
        "\"What's the API contract?\" → Interface docs"
      ],
      "speakerNotes": {
        "talkingPoints": "Agentic search, semantic search, code research—these aren't just discovery tools. They're knowledge extraction and compression engines. The same 50,000 tokens of code can be compressed into different shapes depending on what you ask. No stale caches, no conflicting sources.",
        "timing": "2-3 minutes",
        "discussion": "What other 'compression targets' might be useful? Think about different stakeholders who need to understand code.",
        "context": "This is why maintaining static documentation is often wasteful—you can regenerate the exact view you need, when you need it, from the actual source of truth.",
        "transition": "Now let's apply this to modifying existing code."
      }
    },
    {
      "type": "concept",
      "title": "Spec Shapes for Different Audiences",
      "content": [
        "Product stakeholders: behavioral specs (what users can do)",
        "Engineers: systems specs (components, data flows)",
        "QA: constraint specs (boundaries, edge cases, errors)",
        "Same source code, different compression targets"
      ],
      "speakerNotes": {
        "talkingPoints": "When modifying existing code, extract specs shaped for whoever needs to approve or understand the change. Product needs 'users can have up to 5 sessions'. Engineers need 'SessionManager enforces via Redis sorted set'. QA needs 'boundary: exactly 5, edge: 6th evicts oldest'.",
        "timing": "2-3 minutes",
        "discussion": "How do you currently communicate changes to different stakeholders? Do you use different formats?",
        "context": "This is the 'extract the spec from code' step. Use grounding techniques to surface current implementation in the shape needed by your audience.",
        "transition": "Once you have the extracted spec, here's the modification workflow."
      }
    },
    {
      "type": "codeExecution",
      "title": "The Modification Workflow",
      "steps": [
        {
          "line": "1. Extract spec from current implementation",
          "highlightType": "execution",
          "annotation": "Use grounding tools to surface knowledge from code"
        },
        {
          "line": "2. Shape spec for your audience",
          "highlightType": "prediction",
          "annotation": "Product, engineering, or QA perspective"
        },
        {
          "line": "3. Modify the spec with desired changes",
          "highlightType": "human",
          "annotation": "Edit requirements in extracted spec"
        },
        {
          "line": "4. Gap-analyze: current vs modified spec",
          "highlightType": "prediction",
          "annotation": "What exists? What's missing? What conflicts?"
        },
        {
          "line": "5. Research → Plan → Execute → Validate",
          "highlightType": "execution",
          "annotation": "Standard four-phase workflow from earlier lessons"
        },
        {
          "line": "6. Delete spec files and scaffolding",
          "highlightType": "summary",
          "annotation": "Code is now the source of truth again"
        }
      ],
      "speakerNotes": {
        "talkingPoints": "This workflow respects single source of truth: extract knowledge, modify it, re-implement, then delete the temporary artifacts. Gap analysis bridges 'where we are' to 'where we want to be'. The modified spec feeds your planning phase.",
        "timing": "3-4 minutes",
        "discussion": "How does this compare to your current modification workflow? What step is most often skipped?",
        "context": "Notice step 6—this is where most teams fail. They keep the spec 'for documentation' and create the duplicate knowledge problem.",
        "transition": "Here's the insight: you've been doing SDD all along if you've followed this course."
      }
    },
    {
      "type": "concept",
      "title": "Context Window as Working Spec",
      "content": [
        "Grounding before modifying = extracting the spec",
        "Requirements in your prompt = updating the spec",
        "Agent implements = coding from spec",
        "Closing conversation = spec served its purpose"
      ],
      "speakerNotes": {
        "talkingPoints": "If you've followed this course, you've been practicing SDD all along. Every time you ground in the codebase, describe requirements, have the agent implement, and close the conversation—that's Spec Driven Development. The spec lives in your context window—RAM, not disk.",
        "timing": "2-3 minutes",
        "discussion": "Does thinking of the context window as a 'spec file' change how you'll structure your prompts?",
        "context": "The context window is perfect for single-session tasks. No file to delete because no file was created.",
        "transition": "But what about larger tasks that span multiple sessions?"
      }
    },
    {
      "type": "comparison",
      "title": "When to Persist Specs",
      "neutral": true,
      "left": {
        "label": "Persist Specs When",
        "content": [
          "Work spans multiple days/sessions",
          "Scope exceeds ~100k token context",
          "Multiple agents/people coordinate",
          "Architectural decisions need time"
        ]
      },
      "right": {
        "label": "Keep Ephemeral When",
        "content": [
          "Task completes in one session",
          "Iterating quickly (hours, not days)",
          "Scope fits comfortably in context",
          "Single agent, single engineer"
        ]
      },
      "speakerNotes": {
        "talkingPoints": "For single-session tasks, the context window is your spec file. Larger tasks need coordination across sessions. The key distinction: persisted specs are still scaffolding—they get deleted after implementation, just with a longer lifetime.",
        "timing": "2-3 minutes",
        "discussion": "Think of your current project. Which tasks would need persisted specs? Which could stay in context?",
        "context": "Remember: specs are scaffolding, not architecture. Even persisted specs have a deletion date.",
        "transition": "Let's summarize the key principles of Spec Driven Development."
      }
    },
    {
      "type": "takeaway",
      "title": "Key Takeaways",
      "content": [
        "Codebase encodes all knowledge",
        "Delete specs after implementation",
        "Extract, modify, implement, delete",
        "Regenerate specs on-demand"
      ],
      "speakerNotes": {
        "talkingPoints": "Your codebase is your knowledge base—keep it consistent. SDD adds knowledge systematically through expansion. Specs have a lifecycle: context window for single sessions, files for multi-session, but always deleted after implementation. Code research tools extract knowledge dynamically—no static docs needed.",
        "timing": "2 minutes",
        "discussion": "Which of these principles will be hardest to adopt in your current team? What resistance do you anticipate?",
        "context": "The hardest part is often convincing teams to delete spec files. The instinct to 'preserve documentation' is strong but counterproductive.",
        "transition": "In the next lesson, we'll explore how to scale these practices across larger teams and more complex projects."
      }
    }
  ]
}