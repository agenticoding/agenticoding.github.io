{
  "metadata": {
    "title": "Project Onboarding",
    "lessonId": "lesson-6-project-onboarding",
    "estimatedDuration": "30-40 minutes",
    "learningObjectives": [
      "Structure hierarchical context files",
      "Choose AGENTS.md vs CLAUDE.md",
      "Bootstrap context with AI",
      "Apply security best practices"
    ]
  },
  "slides": [
    {
      "type": "title",
      "title": "Project Onboarding",
      "subtitle": "Codify project context for AI agents",
      "content": [],
      "speakerNotes": {
        "talkingPoints": "When you join a new project, the first week is brutal—unfamiliar architecture, tribal knowledge buried in Slack, undocumented scripts. AI agents face the same problem, except they can't grab coffee with a senior engineer. They see exactly what's in their context window and nothing more.",
        "timing": "1-2 minutes",
        "discussion": "Ask students: How long did it take you to become productive on your current project? What knowledge wasn't documented?",
        "context": "This lesson addresses the fundamental gap between human onboarding (gradual knowledge accumulation) and AI onboarding (single context window snapshot).",
        "transition": "Let's explore how context files solve this problem by giving agents 'project memory'..."
      }
    },
    {
      "type": "concept",
      "title": "The Context File Ecosystem",
      "content": [
        "Context files inject project knowledge into system prompts",
        "Give agents 'project memory' without repeated explanations",
        "Two approaches: AGENTS.md (vendor-neutral) vs CLAUDE.md (hierarchical)",
        "Industry convergence on markdown-based configuration"
      ],
      "speakerNotes": {
        "talkingPoints": "Context files are markdown documents injected between the system prompt and your input. They transform generic code generators into project-aware operators. The industry has converged on two main approaches, each with distinct advantages.",
        "timing": "2-3 minutes",
        "discussion": "How many of you have context files in your current projects? What format are you using?",
        "context": "Over 20,000 open-source projects now use AGENTS.md. Claude Code introduced hierarchical CLAUDE.md for more sophisticated context management.",
        "transition": "Let's compare these two approaches and understand when to use each..."
      }
    },
    {
      "type": "comparison",
      "title": "AGENTS.md vs CLAUDE.md",
      "neutral": true,
      "left": {
        "label": "AGENTS.md",
        "content": [
          "Single file at repository root",
          "One file loaded (no merging)",
          "No hierarchy support",
          "Works with Copilot, Cursor, Windsurf",
          "Not supported by Claude Code"
        ]
      },
      "right": {
        "label": "CLAUDE.md",
        "content": [
          "Multiple files at any level",
          "All applicable files merged",
          "Global → root → subdirs hierarchy",
          "Specific overrides general rules",
          "Claude Code only"
        ]
      },
      "speakerNotes": {
        "talkingPoints": "AGENTS.md is the vendor-neutral standard—one universal file at your repo root. CLAUDE.md is a hierarchical system where multiple files are loaded and merged based on working directory. Both approaches are valid; your choice depends on tooling and project complexity.",
        "timing": "3-4 minutes",
        "discussion": "Which approach fits better with your team's tooling? Are you using multiple AI tools that need to share context?",
        "context": "If your team uses mixed tools, you can use @linking in CLAUDE.md to reference AGENTS.md, maintaining a single source of truth.",
        "transition": "Now let's explore how hierarchical context works across user, project, and module levels..."
      }
    },
    {
      "type": "concept",
      "title": "Hierarchical Context Levels",
      "content": [
        "Global: Personal preferences across all projects (~/.claude/CLAUDE.md)",
        "Project: Tech stack, architecture, conventions (repo root)",
        "Module: Subdirectory-specific overrides",
        "More specific instructions override general ones",
        "Non-conflicting rules from all levels remain active"
      ],
      "speakerNotes": {
        "talkingPoints": "Context operates at different levels of specificity. Global context contains your personal coding style and mindset. Project-level captures tech stack and architecture. Module-level provides subdirectory overrides. The system merges all applicable files intelligently.",
        "timing": "2-3 minutes",
        "discussion": "What kinds of rules would you put at global vs project level? Think about preferences that follow you vs codebase-specific conventions.",
        "context": "This layered approach prevents duplication—define universal preferences once globally, project standards at root, and module-specific overrides only where needed.",
        "transition": "Let's look at a real production example of global-level context..."
      }
    },
    {
      "type": "code",
      "title": "Global Context Example: ~/.claude/CLAUDE.md",
      "language": "markdown",
      "code": "# Mindset\nYou are a senior architect with 20 years of experience.\n- Gather thorough information with tools before solving\n- Work in explicit steps - ask clarifying questions when uncertain\n- BE CRITICAL - validate assumptions, don't trust code blindly\n- MINIMALISM ABOVE ALL - less code is better code\n\n# Architecture First\nLEARN THE SURROUNDING ARCHITECTURE BEFORE CODING.\n- Understand the big picture and how components fit\n- Find and reuse existing code - never duplicate\n- Match surrounding patterns and style\n\n# Critical Constraints\n- NEVER Commit without explicit request\n- NEVER Leave temporary/backup files\n- NEVER Assume your code works - always verify\n- ALWAYS Clean up after completing tasks",
      "caption": "Personal preferences that apply across all projects",
      "speakerNotes": {
        "talkingPoints": "This is the course author's actual global CLAUDE.md. Notice the sections: Mindset establishes the agent's persona, Architecture First ensures code comprehension before modification, and Critical Constraints prevent common mistakes. These rules apply to every project without repetition.",
        "timing": "3-4 minutes",
        "discussion": "What personal preferences would you codify? Think about mistakes you've seen AI make repeatedly.",
        "context": "Global context is particularly powerful for operational rules like 'never commit without asking' or 'always run tests after changes'—rules that prevent costly mistakes.",
        "transition": "Now let's see how project-level context captures codebase-specific knowledge..."
      }
    },
    {
      "type": "code",
      "title": "Project Context Example: CLAUDE.md",
      "language": "markdown",
      "code": "# AI Coding Course - Project Context\n\n## Mindeset\nYou are an expert technical writer specializing in explaining\ncomplex topics to experienced software engineers.\n\n## Technology Stack\n**Platform:** Docusaurus 3.9.2 (Static site generator)\n**Languages:** TypeScript 5.6.2, React 19.0\n\n## Development Commands\n```bash\ncd website && npm start    # Start dev server\nnpm run build              # Production build\nnpm run deploy             # Deploy to GitHub Pages\n```\n\n## Tone & Communication Style\n**Coworker-level communication** - Professional, direct\n- Assume strong fundamentals\n- Skip basic explanations - link to external docs\n- Focus on practical application",
      "caption": "Tech stack, commands, and conventions for one codebase",
      "speakerNotes": {
        "talkingPoints": "This is the actual CLAUDE.md from the AI Coding Course repository. It captures what a new team member needs in the first hour: tech stack specifics, common commands, and communication style expectations. Notice it sets a persona specific to this project (technical writer) that overrides the global architect persona.",
        "timing": "3-4 minutes",
        "discussion": "What tribal knowledge exists in your project that would benefit from being codified? Think about things you'd tell a new hire on day one.",
        "context": "Project context should be concise—your README contains 90% of what AI needs. CLAUDE.md adds only AI-specific operational context.",
        "transition": "Before we discuss generating these files, let's address a critical security consideration..."
      }
    },
    {
      "type": "concept",
      "title": "Security Considerations",
      "content": [
        "Context files are injected directly into system prompts",
        "\"Rules File Backdoor\" attacks identified by researchers",
        "Malicious instructions via Unicode or evasion techniques",
        "Treat context files like code: version-controlled, reviewed",
        "Keep files minimal to reduce attack surface"
      ],
      "speakerNotes": {
        "talkingPoints": "Security researchers have identified 'Rules File Backdoor' attacks where malicious instructions are injected using Unicode characters or evasion techniques. Because context files are injected directly into prompts, they're a potential attack vector. Treat them like any other code—version control, code review, minimal scope.",
        "timing": "2-3 minutes",
        "discussion": "How would you detect malicious content in a context file during code review? What Unicode tricks should you watch for?",
        "context": "This isn't theoretical—attacks have been demonstrated in the wild. The mitigation is straightforward: review context files carefully, keep them minimal, and don't copy-paste from untrusted sources.",
        "transition": "Now let's explore how to bootstrap context files using AI itself..."
      }
    },
    {
      "type": "concept",
      "title": "Automated Generation: Bootstrap with AI",
      "content": [
        "Apply the four-phase workflow to generate context files",
        "Research: ChunkHound for architecture, ArguSeek for best practices",
        "Plan: Synthesize codebase insights into structured file plan",
        "Execute: Generate context file with prompt optimization",
        "Validate: Test with typical task, iterate on gaps"
      ],
      "speakerNotes": {
        "talkingPoints": "The meta-move: use the techniques from lessons 3-5 to generate context files automatically. Instead of manually drafting AGENTS.md, let agents bootstrap their own context through systematic research, planning, and execution.",
        "timing": "2-3 minutes",
        "discussion": "What's the advantage of AI-generated context files over manually written ones? What might be missing?",
        "context": "AI can discover patterns and conventions you've internalized but never documented. However, add tribal knowledge manually afterward—production incidents, team conventions, non-obvious gotchas that only humans know.",
        "transition": "Let's look at the specific prompt for generating AGENTS.md..."
      }
    },
    {
      "type": "code",
      "title": "Generate AGENTS.md Prompt",
      "language": "text",
      "code": "Generate AGENTS.md for this project.\nUse the code research tool to learn the project architecture, tech stack,\nhow auth works, testing conventions, coding style, and deployment process.\nUse ArguSeek to fetch current best practices for the tech stack used and the\nlatest security guidelines.\n\nCreate a concise file (≤200 lines) with sections:\n- Tech Stack\n- Development Commands (modified for non-interactive execution)\n- Architecture (high-level structure)\n- Coding Conventions and Style\n- Critical Constraints\n- Common Pitfalls (if found).\n\nDo NOT duplicate information already in README or code comments—instead, focus\nexclusively on AI-specific operations: environment variables, non-obvious\ndependencies, and commands requiring modification for agents.",
      "caption": "Grounded prompt combining codebase analysis and ecosystem research",
      "speakerNotes": {
        "talkingPoints": "This prompt demonstrates grounding from Lesson 5: ChunkHound provides codebase-specific context, ArguSeek provides current ecosystem knowledge, and structured instructions ensure methodical execution. The 200-line limit enforces conciseness. Note the explicit instruction to avoid duplicating README content.",
        "timing": "3-4 minutes",
        "discussion": "What additional sections would you add for your project? Security guidelines? API patterns? Database schema?",
        "context": "Adapt sections for your project needs: Security Guidelines for sensitive data, API Integration Patterns for microservices, Database Schema for data-intensive apps, Deployment Checklist for complex workflows.",
        "transition": "Let's talk about what makes context files effective in practice..."
      }
    },
    {
      "type": "concept",
      "title": "Context File Best Practices",
      "content": [
        "Keep files concise (≤200 lines) to preserve context budget",
        "Focus on AI-specific operations, not README duplicates",
        "Use imperative language: 'NEVER commit' not 'try to avoid'",
        "Include tribal knowledge: incidents, gotchas, conventions",
        "Review and update after production issues"
      ],
      "speakerNotes": {
        "talkingPoints": "Effective context files are concise and focused. Use strong imperative language—'NEVER' and 'ALWAYS' are more effective than suggestions. Include the tribal knowledge that exists in your team's heads but nowhere in documentation. Update files after production incidents reveal gaps.",
        "timing": "2-3 minutes",
        "discussion": "Think of a recent production incident. What rule in a context file could have prevented it?",
        "context": "Context files evolve with your project. Treat them as living documents that capture lessons learned, not static configuration.",
        "transition": "Let's wrap up with key takeaways for implementing context files in your projects..."
      }
    },
    {
      "type": "takeaway",
      "title": "Key Takeaways",
      "content": [
        "Context files provide agent memory",
        "Hierarchy: global → project → module",
        "Bootstrap context files using AI",
        "Treat context files as code",
        "Update after production incidents"
      ],
      "speakerNotes": {
        "talkingPoints": "Context files transform generic AI into project-aware operators. The hierarchical system prevents duplication while allowing specificity. Use AI to bootstrap context, but add human tribal knowledge. Treat these files with the same rigor as production code—version control, review, and continuous improvement.",
        "timing": "2-3 minutes",
        "discussion": "What's your first step after this lesson? Creating a global CLAUDE.md? Adding AGENTS.md to your project?",
        "context": "The investment in context files pays off immediately—fewer repeated explanations, more accurate code generation, and reduced iteration cycles.",
        "transition": "Next lesson: Planning & Execution—how to structure agent workflows for complex tasks."
      }
    }
  ]
}