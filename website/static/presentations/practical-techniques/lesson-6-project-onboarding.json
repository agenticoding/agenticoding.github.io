{
  "metadata": {
    "title": "Project Onboarding Context",
    "lessonId": "lesson-6-project-onboarding",
    "estimatedDuration": "35-45 minutes",
    "learningObjectives": [
      "Master hierarchical context systems",
      "Bootstrap context with AI",
      "Choose AGENTS.md vs CLAUDE.md",
      "Ground agents in codebase"
    ]
  },
  "slides": [
    {
      "type": "title",
      "title": "Project Onboarding Context",
      "subtitle": "Codify project knowledge for AI agents",
      "content": [],
      "speakerNotes": {
        "talkingPoints": "This lesson teaches you how to transform AI agents from generic code generators into project-aware operators using hierarchical context files. We'll cover the ecosystem of AGENTS.md vs CLAUDE.md, their trade-offs, and how to bootstrap context files using AI.",
        "timing": "1 minute",
        "discussion": "Ask students: How many have onboarded to a new codebase in the last year? What took the longest to understand?",
        "context": "Context files solve the same problem for AI agents that documentation and tribal knowledge solve for human engineers—except agents can't ask senior engineers for help.",
        "transition": "Let's start by understanding the fundamental problem AI agents face when joining your project."
      }
    },
    {
      "type": "concept",
      "title": "The Onboarding Problem",
      "content": [
        "Agents see only their context window (~200K tokens)",
        "No memory of previous conversations",
        "No understanding of 'how we do things here'",
        "Same challenges as new human engineers—but worse"
      ],
      "speakerNotes": {
        "talkingPoints": "When you join a new project, you learn through documentation, Slack history, and coffee chats with senior engineers. AI agents can't do any of that—they only see what's in their context window right now. Context files solve this by codifying project knowledge in machine-readable format.",
        "timing": "2-3 minutes",
        "discussion": "What tribal knowledge exists in your current project that isn't documented? Configuration quirks? Deployment gotchas?",
        "context": "In production, this manifests as agents suggesting deprecated patterns, violating coding conventions, or missing critical environment setup steps.",
        "transition": "The solution is context files—let's understand the two competing standards."
      }
    },
    {
      "type": "comparison",
      "title": "Context File Standards",
      "neutral": true,
      "left": {
        "label": "AGENTS.md",
        "content": [
          "Single file at repository root",
          "Vendor-neutral (Cursor, Windsurf, Copilot)",
          "No hierarchy—one universal file",
          "Not supported by Claude Code"
        ]
      },
      "right": {
        "label": "CLAUDE.md",
        "content": [
          "Multiple files at any level",
          "Claude Code only",
          "Hierarchical merging (global → root → subdirs)",
          "Specific instructions override general"
        ]
      },
      "speakerNotes": {
        "talkingPoints": "Both approaches are valid—choose based on your tooling and project complexity. AGENTS.md works across most AI tools but lacks hierarchy. CLAUDE.md provides powerful layering but only works in Claude Code. Teams using mixed tools can reference AGENTS.md from CLAUDE.md using @linking.",
        "timing": "4-5 minutes",
        "discussion": "Which tools does your team use? Do you need hierarchical context for monorepos or multi-module projects?",
        "context": "20,000+ open-source projects use AGENTS.md. Claude Code's hierarchical system shines in large codebases where different modules have different conventions.",
        "transition": "Let's see how hierarchical context works in practice with real production examples."
      }
    },
    {
      "type": "concept",
      "title": "Hierarchical Context Merging",
      "content": [
        "Global: ~/.claude/CLAUDE.md (personal preferences)",
        "Project: /project/CLAUDE.md (tech stack, conventions)",
        "Module: /project/module/CLAUDE.md (overrides)",
        "All applicable files merged based on working directory"
      ],
      "speakerNotes": {
        "talkingPoints": "Claude Code's hierarchy lets you define universal preferences globally, project standards at the root, and module-specific overrides in subdirectories. When you run a command from /project/module, Claude merges global + project + module context, with more specific instructions overriding general ones while non-conflicting rules remain active.",
        "timing": "3 minutes",
        "discussion": "Where would you put coding style rules? Where would you put database migration conventions for a specific microservice?",
        "context": "This prevents duplicating rules across files—your global preference for minimalism applies everywhere unless a specific module overrides it.",
        "transition": "Let's look at a production global context file to see what belongs at that level."
      }
    },
    {
      "type": "code",
      "title": "Global Context Example",
      "language": "markdown",
      "code": "# Mindset\nYou are a senior architect with 20 years of experience across all software domains.\n- Gather thorough information with tools before solving\n- Work in explicit steps - ask clarifying questions when uncertain\n- BE CRITICAL - validate assumptions, don't trust code blindly\n- MINIMALISM ABOVE ALL - less code is better code\n\n# Architecture First\nLEARN THE SURROUNDING ARCHITECTURE BEFORE CODING.\n- Understand the big picture and how components fit\n- Find and reuse existing code - never duplicate\n- When finding duplicate responsibilities, refactor to shared core\n- Match surrounding patterns and style\n\n# Critical Constraints\n- NEVER Commit without explicit request\n- NEVER Leave temporary/backup files (we have version control)\n- NEVER Hardcode keys or credentials\n- NEVER Assume your code works - always verify",
      "caption": "Course author's actual ~/.claude/CLAUDE.md—personal preferences across all projects",
      "speakerNotes": {
        "talkingPoints": "This is the course author's real global context file. Notice it contains universal preferences: mindset, architectural principles, and constraints that apply to every project. It doesn't mention specific tech stacks or project structures—those belong in project-level context.",
        "timing": "3-4 minutes",
        "discussion": "What personal coding preferences would you put in your global context? Testing philosophy? Error handling approach?",
        "context": "Global context is where you encode your engineering principles—things you'd tell any AI agent regardless of the project. Think of it as your personal 'how I code' manifesto.",
        "transition": "Now let's see what belongs in project-level context."
      }
    },
    {
      "type": "code",
      "title": "Project Context Example",
      "language": "markdown",
      "code": "# AI Coding Course - Project Context\n\n## Mindeset\nYou are an expert technical writer specializing in explaining complex topics to experienced software engineers.\n\n## Technology Stack\n**Platform:** Docusaurus 3.9.2 (Static site generator)\n**Languages:** TypeScript 5.6.2, React 19.0\n\n## Development Commands\n```bash\ncd website && npm start              # Start dev server (localhost:3000)\nnpm run build                        # Production build\n```\n\n## Tone & Communication Style\n**Coworker-level communication** - Professional, direct, no hand-holding\n- Assume strong fundamentals (data structures, design patterns, system design)\n- Focus on practical application and production considerations",
      "caption": "This course's actual CLAUDE.md—tech stack and project-specific conventions",
      "speakerNotes": {
        "talkingPoints": "This is the actual project context for this AI Coding Course repository. Notice it specifies tech stack, development commands, and communication style—information specific to this codebase. It tells agents this is a Docusaurus site for senior engineers, so they should write concise technical content.",
        "timing": "3-4 minutes",
        "discussion": "What would your project context include? Database schema location? Auth implementation details? Deployment process?",
        "context": "Project context answers: What tech stack? What conventions? What tribal knowledge would a new team member need in their first hour?",
        "transition": "Now here's the meta-move: instead of manually writing these files, use AI to bootstrap them."
      }
    },
    {
      "type": "concept",
      "title": "Automated Context Generation",
      "content": [
        "Research: ChunkHound learns codebase architecture",
        "Research: ArguSeek fetches framework best practices",
        "Plan: Synthesize into structured context file",
        "Execute: Generate AGENTS.md or CLAUDE.md",
        "Validate: Test with typical task, iterate"
      ],
      "speakerNotes": {
        "talkingPoints": "This is the meta-move: apply lessons 3-5 to generate context files automatically. Use ChunkHound to understand your codebase architecture and ArguSeek to fetch current ecosystem knowledge. The agent synthesizes both into a production-ready context file in one iteration—not weeks of manual curation.",
        "timing": "3 minutes",
        "discussion": "What would you add manually afterward? Production incidents? Team conventions? Non-obvious gotchas?",
        "context": "This demonstrates grounding from Lesson 5: ChunkHound provides codebase-specific context, ArguSeek provides current ecosystem knowledge. The result is accurate, not hallucinated.",
        "transition": "Let's see the exact prompt you'd use to bootstrap a context file."
      }
    },
    {
      "type": "code",
      "title": "Bootstrap Prompt Example",
      "language": "text",
      "code": "Generate AGENTS.md for this project.\nUse the code research tool to to learn the project architecture, tech stack,\nhow auth works, testing conventions, coding style, and deployment process.\nUse ArguSeek to fetch current best practices for the tech stack used and the\nlatest security guidelines.\n\nCreate a concise file (≤500 lines) with sections:\n- Tech Stack\n- Development Commands (modified for non-interactive execution)\n- Architecture (high-level structure)\n- Coding Conventions and Style\n- Critical Constraints\n- Common Pitfalls (if found).\n\nDo NOT duplicate information already in README or code comments—instead, focus\nexclusively on AI-specific operations: environment variables, non-obvious\ndependencies, and commands requiring modification for agents.",
      "caption": "Prompt for automated context file generation using grounding tools",
      "speakerNotes": {
        "talkingPoints": "This prompt demonstrates structured grounding: it directs the agent to use ChunkHound for codebase-specific research and ArguSeek for ecosystem knowledge. Notice the explicit constraints—concise file, no duplication of README content, focus on AI-specific operations. This prevents bloated context files.",
        "timing": "4-5 minutes",
        "discussion": "What would you modify in this prompt for your project? Would you add security review sections? Performance benchmarks?",
        "context": "In production, this generates a context file in minutes that would take days to manually curate. You then add tribal knowledge manually—things only humans know from production incidents.",
        "transition": "Let's talk about a critical security consideration before we wrap up."
      }
    },
    {
      "type": "concept",
      "title": "Security Considerations",
      "content": [
        "Context files injected directly into system prompts",
        "Vulnerable to 'Rules File Backdoor' attacks",
        "Malicious instructions via Unicode or evasion techniques",
        "Treat context files like code: minimal, version-controlled, reviewed"
      ],
      "speakerNotes": {
        "talkingPoints": "Security researchers have identified attacks where malicious instructions are injected into context files using Unicode characters or prompt evasion. Since these files are injected directly into system prompts, they can override safety constraints. Treat context files like production code—keep them minimal, version-controlled, and require code review.",
        "timing": "2-3 minutes",
        "discussion": "How does your team handle code review for configuration files? Should context files go through the same process?",
        "context": "Real-world scenario: A compromised dependency could inject malicious AGENTS.md during npm install. Version control and code review catch this.",
        "transition": "Let's summarize the key takeaways from this lesson."
      }
    },
    {
      "type": "takeaway",
      "title": "Key Takeaways",
      "content": [
        "Context files codify project memory",
        "Choose AGENTS.md or CLAUDE.md strategically",
        "Bootstrap context with AI agents",
        "Treat context files as code"
      ],
      "speakerNotes": {
        "talkingPoints": "Context files transform AI agents from generic assistants into project-aware operators. Choose AGENTS.md for vendor-neutral simplicity or CLAUDE.md for hierarchical power. Bootstrap them automatically using ChunkHound and ArguSeek—don't manually curate for weeks. And treat them like code: minimal, version-controlled, reviewed.",
        "timing": "2 minutes",
        "discussion": "What's your next step? Generate AGENTS.md for your current project? Set up global CLAUDE.md?",
        "context": "The meta-lesson: AI agents can onboard themselves to your codebase using the same techniques you've learned in lessons 3-5. Apply what you've learned recursively.",
        "transition": "Next lesson: Planning and Execution—how to structure complex multi-step tasks."
      }
    }
  ]
}