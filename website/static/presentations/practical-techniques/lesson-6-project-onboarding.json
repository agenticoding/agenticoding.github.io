{
  "metadata": {
    "title": "Lesson 6: Project Onboarding",
    "lessonId": "lesson-6-project-onboarding",
    "estimatedDuration": "35-40 minutes",
    "learningObjectives": [
      "Structure context files hierarchically",
      "Choose AGENTS.md vs CLAUDE.md correctly",
      "Codify project-specific AI knowledge",
      "Bootstrap context with AI automation"
    ]
  },
  "slides": [
    {
      "type": "title",
      "title": "Project Onboarding",
      "subtitle": "Giving AI Agents Project Memory",
      "content": [],
      "speakerNotes": {
        "talkingPoints": "When you join a new project, the first week is brutal—unfamiliar architecture, tech stack decisions, tribal knowledge. AI agents face the same problem. They see only what's in their context window (~200K tokens) and nothing more. This lesson teaches you how to codify your project context so agents become project-aware operators instead of generic code generators.",
        "timing": "1 minute",
        "discussion": "Ask students: What's the most frustrating thing about onboarding to a new project? Most will mention 'not knowing how we do things here.'",
        "context": "The central problem in production: without context, agents make decisions based on generic patterns, not your project's conventions.",
        "transition": "Let's start with the core problem: why do agents struggle on unfamiliar projects?"
      }
    },
    {
      "type": "concept",
      "title": "The Context Deficit Problem",
      "content": [
        "Agents see only ~200K tokens in context window",
        "No memory of previous conversations",
        "No understanding of 'how we do things here'",
        "Each task starts from zero project knowledge",
        "Result: generic decisions instead of project-aligned code"
      ],
      "speakerNotes": {
        "talkingPoints": "AI agents lack what humans absorb naturally: your project's unwritten rules, conventions, tech stack decisions, and architectural patterns. They can't grab coffee with a senior engineer. They see exactly what's in their context and nothing more. The solution is deliberate codification.",
        "timing": "2 minutes",
        "discussion": "Ask: What tribal knowledge in your project would surprise a new team member? Those are exactly the things agents struggle with.",
        "context": "Production insight: Agents generate code faster than humans but make decisions based on training data, not your project standards. Context files close this gap.",
        "transition": "The industry has converged on two solutions: AGENTS.md and CLAUDE.md. Let's compare them."
      }
    },
    {
      "type": "concept",
      "title": "Context File Ecosystem Overview",
      "content": [
        "AGENTS.md: vendor-neutral standard, single file",
        "Supports GitHub Copilot, Cursor, Windsurf, etc.",
        "CLAUDE.md: hierarchical, Claude Code only",
        "Multiple files (global, project, module level)",
        "More specific files override general ones"
      ],
      "speakerNotes": {
        "talkingPoints": "Two standards emerged. AGENTS.md is the vendor-neutral consensus adopted by 20,000+ projects. CLAUDE.md is Claude Code's extension that supports hierarchical context—multiple files at different levels that are automatically merged. Each has different strengths depending on your tool ecosystem.",
        "timing": "2 minutes",
        "discussion": "Ask students: If your team uses both GitHub Copilot and Claude Code, which standard should you choose? (Answer: AGENTS.md at root for compatibility, then CLAUDE.md for Claude-specific features)",
        "context": "AGENTS.md went into the AI Coding Handbook as the standard. But Claude Code's hierarchical system is more powerful if you're in a Claude-only environment.",
        "transition": "Let's look at a side-by-side comparison of these two approaches."
      }
    },
    {
      "type": "comparison",
      "title": "AGENTS.md vs CLAUDE.md",
      "left": {
        "label": "AGENTS.md (Vendor-Neutral)",
        "content": [
          "Single file at repository root",
          "One context file only",
          "No inheritance or hierarchy",
          "Works with: Copilot, Cursor, Windsurf",
          "Compatible across tool ecosystem"
        ]
      },
      "right": {
        "label": "CLAUDE.md (Claude Code)",
        "content": [
          "Multiple files at any level",
          "All applicable files merged together",
          "Hierarchical: global → root → subdirs",
          "Specific instructions override general",
          "Non-conflicting rules from all levels active"
        ]
      },
      "speakerNotes": {
        "talkingPoints": "The key difference: AGENTS.md is a single file, one shot. CLAUDE.md is a system where multiple files from different directories are loaded and merged based on your working directory. If you work globally with Claude Code, CLAUDE.md's hierarchy lets you avoid repetition. If you're in a mixed-tool team, AGENTS.md is your common language.",
        "timing": "2 minutes",
        "discussion": "Ask: Which approach scales better as your project grows? (CLAUDE.md, because you can customize per module without repeating global rules)",
        "context": "Production teams often have tool diversity. The right choice depends on whether Claude Code is your only tool or one of several.",
        "transition": "What if you need both? There's a clever solution for mixed ecosystems."
      }
    },
    {
      "type": "code",
      "title": "Mixed Ecosystem: Linking Files",
      "language": "text",
      "code": "# ~/.claude/CLAUDE.md\n\nImport shared AGENTS.md using @-notation:\n\n[REFERENCE TO: ../path/to/AGENTS.md]\n\nThen add Claude-specific rules below.\n\nThis maintains a single source of truth\nwhile supporting both file formats.",
      "caption": "Avoid duplication in mixed-tool environments",
      "speakerNotes": {
        "talkingPoints": "If your team uses both Copilot and Claude Code, use this pattern: put shared operational context in AGENTS.md at root, then link to it from your CLAUDE.md with a reference. This way you don't maintain duplicate rules. The reference syntax varies by tool—check Claude Code docs for exact syntax in your version.",
        "timing": "1-2 minutes",
        "discussion": "Ask: Why is avoiding duplication important here? (Because duplicated rules diverge when one is updated)",
        "context": "Real production scenario: A team has some engineers using Copilot (via Copilot extension in their editor) and others using Claude Code. This pattern keeps them synchronized.",
        "transition": "Now let's talk about security—context files are powerful but can be misused."
      }
    },
    {
      "type": "concept",
      "title": "Security Consideration",
      "content": [
        "Context files are injected directly into system prompts",
        "Security researchers found 'Rules File Backdoor' attacks",
        "Evasion techniques use Unicode and obfuscation",
        "Keep context minimal and version-controlled",
        "Code review context files like production code"
      ],
      "speakerNotes": {
        "talkingPoints": "Context files are powerful, which means they're attack surface. Security researchers have demonstrated 'Rules File Backdoor' attacks where malicious instructions are hidden using Unicode or evasion techniques to override your actual system prompt. Treat them like code: minimal, audited, version-controlled.",
        "timing": "1-2 minutes",
        "discussion": "Ask: If someone commits a malicious instruction to CLAUDE.md, what happens? (It gets injected into every prompt you write—privilege escalation via configuration)",
        "context": "This is why context files aren't just organizational—they're a security boundary. Bad actors could hide instructions here to exfiltrate data or bypass checks.",
        "transition": "Now let's zoom into the structure. Context files work best when layered by scope."
      }
    },
    {
      "type": "concept",
      "title": "Hierarchical Context: Three Levels",
      "content": [
        "Global: Personal preferences across all projects",
        "Project: Tech stack, architecture, conventions",
        "Module: Specialized rules for subdirectories",
        "Specific overrides general (CLAUDE.md only)",
        "Non-conflicting rules from all levels merge"
      ],
      "speakerNotes": {
        "talkingPoints": "Think of context files in layers. Global context lives in ~/.claude/CLAUDE.md and applies to every project you work on—your coding style, operational rules, mindset. Project-level context (at repo root) captures the specifics: tech stack, common commands, architectural decisions. Module-level context (in subdirs) can override for specialized areas. The hierarchy means you don't repeat 'my general coding philosophy' in every project.",
        "timing": "2 minutes",
        "discussion": "Ask: Why does hierarchy matter? (Reduces duplication, keeps files maintainable, allows exceptions at appropriate granularity)",
        "context": "If you're working on 5 projects and each has 200 lines of duplicate 'my preferences,' you're maintaining 1000 lines when 200 would suffice.",
        "transition": "Let's see what this looks like in practice. Here's a real global context example."
      }
    },
    {
      "type": "code",
      "title": "Global Context Example",
      "language": "text",
      "code": "# ~/.claude/CLAUDE.md\n# Mindset\nYou are a senior architect with\n20 years of experience.\n\n# Search Protocol\nUse ChunkHound's Code Research tool\nto learn surrounding code style.\nPREFER CODE RESEARCH over sub agents.\n\n# Architecture First\nLEARN surrounding architecture\nBEFORE CODING.\n\n# Coding Standards\nKISS - Keep It Simple\nNo over-engineering\nNo silent errors - failures explicit",
      "caption": "Reusable across all projects",
      "speakerNotes": {
        "talkingPoints": "This is the course author's actual ~/.claude/CLAUDE.md—what they use every day across different projects. It's 20 lines that define how they approach problems: be critical, minimize code, learn architecture first, make failures visible. These rules apply whether they're working on a web app, a data pipeline, or an AI system. They don't repeat this in every project's CLAUDE.md.",
        "timing": "2-3 minutes",
        "discussion": "Ask: What's one rule you'd put in YOUR global context? (Answers reveal individual working styles)",
        "context": "Production pattern: The authors I've worked with all have personal context files. Some are 10 lines, some are 200. The pattern is universal.",
        "transition": "Now zoom into project-level context. This is where project-specific knowledge lives."
      }
    },
    {
      "type": "code",
      "title": "Project Context Example",
      "language": "text",
      "code": "# CLAUDE.md (at repository root)\n# AI Coding Course\n\n## Tone & Communication Style\nCoworker-level communication.\nAssume strong fundamentals.\nSkip basic explanations.\n\n## Technology Stack\nDocusaurus 3.9.2, TypeScript 5.6.2\nReact 19.0\n\n## Development Commands\ncd website && npm start  # dev\nnpm run build            # production\nnpm run deploy           # GitHub Pages",
      "caption": "What new team member needs first hour",
      "speakerNotes": {
        "talkingPoints": "Project-level CLAUDE.md answers 'what's different about THIS project?' Tech stack, how we talk, what commands are standard, deployment pipeline. This is what an AI agent needs to know in the first interaction—architecture, conventions, how to run things. It's much shorter than documenting everything, because the README contains 90% of what's needed. CLAUDE.md adds only AI-specific operational context.",
        "timing": "2-3 minutes",
        "discussion": "Ask: What went wrong last time an agent ran the wrong command in your project? (That's a signal you need project-level context documentation)",
        "context": "Real incident: An agent modified package.json without running npm install because the project context didn't clarify the dependency workflow. One sentence of context prevents that.",
        "transition": "You can write these manually, but the meta-move is to let AI bootstrap them for you. Let's look at how."
      }
    },
    {
      "type": "concept",
      "title": "Automated Bootstrap Process",
      "content": [
        "Research: ChunkHound analyzes your codebase",
        "Plan: Agent synthesizes codebase insights",
        "Execute: Generate context file using optimization",
        "Validate: Test with typical task, iterate",
        "Add tribal knowledge manually afterward"
      ],
      "speakerNotes": {
        "talkingPoints": "The meta-move: Use lessons 3-5 (Research, Planning, Execution) to generate context files automatically instead of manual drafting. ChunkHound scans your architecture, ArguSeek retrieves framework docs, agent synthesizes into a structured plan, then generates the file. You validate by testing—does the agent use it correctly? Then add the human knowledge: incidents, gotchas, unwritten rules that only you know.",
        "timing": "2-3 minutes",
        "discussion": "Ask: Why bootstrap instead of manually write? (Because AI can do pattern analysis at scale, but humans catch the exceptions)",
        "context": "Production workflow: We've seen teams generate base context files in 1 iteration vs 2-3 weeks manual curation. The difference: AI handles breadth (codebase analysis), humans handle depth (tribal knowledge).",
        "transition": "Let's see a concrete prompt that demonstrates this bootstrap process."
      }
    },
    {
      "type": "code",
      "title": "Bootstrap Prompt Example",
      "language": "text",
      "code": "Research: Use ChunkHound's code_research()\nto understand architecture, patterns,\nmodule responsibilities, test conventions.\n\nPlan: Synthesize codebase insights\n(from ChunkHound) and domain knowledge\n(from ArguSeek) into structured plan.\n\nExecute: Generate context file using\nprompt optimization techniques.\n\nValidate: Test with typical task,\niterate based on gaps.\n\nThen: Add tribal knowledge manually.",
      "caption": "Grounded generation avoids hallucination",
      "speakerNotes": {
        "talkingPoints": "This is the structure: First research the codebase systematically (that's what ChunkHound is for), then research the ecosystem (framework docs, best practices), then plan, then execute. The key insight: by grounding the generation in real codebase data and framework documentation, you avoid hallucinated 'context' that doesn't match reality. The prompt uses Chain-of-Thought structure to keep the agent on track.",
        "timing": "2-3 minutes",
        "discussion": "Ask: What could go wrong if you skipped the research phase? (Agent invents conventions instead of discovering them)",
        "context": "This is lesson 5 (Grounding) applied to meta-task of context generation. Systematic research prevents false confidence about what your project actually does.",
        "transition": "Let's wrap up with the key takeaways from this lesson."
      }
    },
    {
      "type": "takeaway",
      "title": "Key Takeaways",
      "content": [
        "Context files give agents project memory without repetition",
        "Choose AGENTS.md for multi-tool teams, CLAUDE.md for Claude-specific hierarchy",
        "Structure context in layers: global, project, module (no duplication)",
        "Automate bootstrap using systematic research → planning → generation"
      ],
      "speakerNotes": {
        "talkingPoints": "Four big ideas: First, context files are the bridge between generic AI and your project-specific needs. Second, the choice between standards matters—pick based on your tool ecosystem. Third, hierarchy prevents duplication and scales. Fourth, the meta-move is to use AI itself to generate context files, not manual curation. Start with what AI discovers about your codebase, then add human knowledge.",
        "timing": "2 minutes",
        "discussion": "Ask: Which takeaway will change how you work? Most students should have one concrete idea of what context file they'll write first.",
        "context": "This lesson teaches the fundamentals of context engineering. In Lesson 7 (Planning & Execution), you'll apply these same ideas to more complex workflows.",
        "transition": "Next lesson covers Planning & Execution—how to structure complex multi-step tasks for AI agents."
      }
    }
  ]
}
