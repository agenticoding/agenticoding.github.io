{
  "metadata": {
    "title": "Project Onboarding with Context Files",
    "lessonId": "lesson-6-project-onboarding",
    "estimatedDuration": "30-40 minutes",
    "learningObjectives": [
      "Structure hierarchical context files",
      "Choose AGENTS.md vs CLAUDE.md",
      "Bootstrap context with AI",
      "Secure context file content"
    ]
  },
  "slides": [
    {
      "type": "title",
      "title": "Project Onboarding with Context Files",
      "subtitle": "Transform agents from generic to project-aware",
      "content": [],
      "speakerNotes": {
        "talkingPoints": "When you join a new project, the first week is brutal—unfamiliar architecture, tribal knowledge in Slack, undocumented scripts. AI agents face the same problem but can't ask senior engineers for help. They see only what's in their context window.",
        "timing": "1-2 minutes",
        "discussion": "Ask: How long did it take you to become productive on your last new project? What information was hardest to find?",
        "context": "This lesson bridges the gap between generic AI assistance and project-aware intelligent operation.",
        "transition": "Let's start with why this matters and what the solution looks like."
      }
    },
    {
      "type": "concept",
      "title": "The Problem: Agents Have No Project Memory",
      "content": [
        "~200K token context window—no memory of yesterday",
        "No understanding of 'how we do things around here'",
        "Can't access tribal knowledge or conventions",
        "Must repeatedly explain tech stack and architecture"
      ],
      "speakerNotes": {
        "talkingPoints": "AI agents see exactly what's in their context window and nothing more. Every conversation starts fresh. They don't remember yesterday's debugging session or know your team's naming conventions unless you tell them every time.",
        "timing": "2 minutes",
        "discussion": "What tribal knowledge exists in your current project that would be impossible for a new hire (or AI) to discover?",
        "context": "This is the fundamental limitation that context files solve—persistent project knowledge.",
        "transition": "The solution is simple: codify your project context in machine-readable files."
      }
    },
    {
      "type": "concept",
      "title": "The Solution: Hierarchical Context Files",
      "content": [
        "Markdown files injected between system prompt and input",
        "Give agents 'project memory' without repetition",
        "Operate at global, project, and module levels",
        "Two standards: AGENTS.md and CLAUDE.md"
      ],
      "speakerNotes": {
        "talkingPoints": "Context files are markdown documents that inject project-specific knowledge directly into the agent's context. They provide persistent memory without requiring you to explain your tech stack every conversation.",
        "timing": "2 minutes",
        "discussion": "Where would you put the most critical context for your project—at what level of specificity?",
        "context": "Industry has converged on these two approaches, each with different strengths.",
        "transition": "Let's compare the two standards and understand when to use each."
      }
    },
    {
      "type": "comparison",
      "title": "AGENTS.md vs CLAUDE.md",
      "neutral": true,
      "left": {
        "label": "AGENTS.md",
        "content": [
          "Single file at repository root",
          "One file loaded—no hierarchy",
          "Works with Copilot, Cursor, Windsurf",
          "Vendor-neutral, 20K+ projects use it"
        ]
      },
      "right": {
        "label": "CLAUDE.md",
        "content": [
          "Multiple files at any level",
          "Hierarchical: global → root → subdirs",
          "Specific overrides general rules",
          "Claude Code only, advanced features"
        ]
      },
      "speakerNotes": {
        "talkingPoints": "Both approaches are valid—the choice depends on your team's tooling and project complexity. AGENTS.md is universal but flat. CLAUDE.md is hierarchical but Claude-specific. In mixed-tool teams, you can use @linking to reference AGENTS.md from CLAUDE.md.",
        "timing": "3-4 minutes",
        "discussion": "What tools does your team use? Would a hierarchical system benefit your project structure?",
        "context": "Note that Claude Code doesn't support AGENTS.md—use CLAUDE.md instead if you're using Claude Code.",
        "transition": "Let's look at what goes in these files, starting with global-level context."
      }
    },
    {
      "type": "code",
      "title": "Global Context: ~/.claude/CLAUDE.md",
      "language": "markdown",
      "code": "# Mindset\nYou are a senior architect with 20 years of experience.\n- Gather thorough information with tools before solving\n- Work in explicit steps - ask clarifying questions when uncertain\n- BE CRITICAL - validate assumptions, don't trust code blindly\n- MINIMALISM ABOVE ALL - less code is better code\n\n# Coding Standards\nKISS - Keep It Simple:\n- Write minimal code that compiles and lints cleanly\n- Fix bugs by deleting code when possible\n- No over-engineering, no temporary compatibility layers\n- No silent errors - failures must be explicit\n\n# Critical Constraints\n- NEVER Commit without explicit request\n- NEVER Leave temporary/backup files\n- NEVER Hardcode keys or credentials\n- ALWAYS Clean up after completing tasks",
      "caption": "Personal preferences that apply across ALL projects",
      "speakerNotes": {
        "talkingPoints": "This is the course author's actual global context file. It defines mindset, coding philosophy, and operational rules that apply universally. Notice the mix of principles (minimalism) and explicit constraints (never commit without permission).",
        "timing": "3 minutes",
        "discussion": "What personal coding preferences would you codify? What are your non-negotiable constraints?",
        "context": "Global context lives in your home directory and gets merged with project-specific context.",
        "transition": "Now let's see what project-level context looks like."
      }
    },
    {
      "type": "code",
      "title": "Project Context: Tech Stack & Commands",
      "language": "markdown",
      "code": "## Technology Stack\n**Platform:** Docusaurus 3.9.2 (Static site generator)\n**Languages:** TypeScript 5.6.2, React 19.0\n**Key Features:**\n- Live code blocks with `@docusaurus/theme-live-codeblock`\n- MDX support for interactive components\n- Full-text search with `@easyops-cn/docusaurus-search-local`\n\n## Development Commands\n```bash\n# Development\ncd website && npm start              # Start dev server\nnpm run build                        # Production build\nnpm run serve                        # Preview production build\n\n# Deployment\nnpm run deploy                       # Deploy to GitHub Pages\n```",
      "caption": "What a new team member needs in the first hour",
      "speakerNotes": {
        "talkingPoints": "Project-level context captures tech stack specifics and common commands. This is from an actual course repository. Note the precision—version numbers, specific packages, exact commands. Agents work best with concrete details.",
        "timing": "2-3 minutes",
        "discussion": "What commands does every new developer on your project need to know? What takes the longest to discover?",
        "context": "Commands should be modified for non-interactive execution when needed—agents can't respond to prompts.",
        "transition": "Project context also includes conventions and deployment details."
      }
    },
    {
      "type": "code",
      "title": "Project Context: Conventions & Style",
      "language": "markdown",
      "code": "## Tone & Communication Style\n**Coworker-level communication** - Professional, direct, no hand-holding\n- Assume strong fundamentals (data structures, design patterns)\n- Skip basic explanations - link to external docs if needed\n- Focus on practical application and production considerations\n\n## Content Philosophy\n**Production-Ready Architecture Focus**\n- Real-world examples over toy demos\n- Scalability and maintainability considerations\n- Security and performance implications\n\n**Minimalism & Clarity**\n- Concise explanations\n- Code examples that compile and run\n- Clear learning objectives per lesson",
      "caption": "Tribal knowledge codified—style, philosophy, expectations",
      "speakerNotes": {
        "talkingPoints": "This section captures what's usually buried in Slack threads and onboarding docs. The tone guidance is particularly valuable—it prevents agents from being overly verbose or explaining basics to senior engineers.",
        "timing": "2 minutes",
        "discussion": "What unwritten rules exist in your codebase that would benefit from explicit documentation?",
        "context": "These conventions shape how the agent communicates and structures its output.",
        "transition": "Now let's look at how to bootstrap these files automatically using AI."
      }
    },
    {
      "type": "concept",
      "title": "Bootstrap Context with AI",
      "content": [
        "Use four-phase workflow from Lessons 3-5",
        "Research: ChunkHound for architecture, ArguSeek for docs",
        "Plan: Synthesize into structured context file",
        "Execute: Generate using model-specific techniques",
        "Validate: Test with typical task, iterate on gaps"
      ],
      "speakerNotes": {
        "talkingPoints": "The meta-move: use agents to generate their own context files. ChunkHound analyzes your codebase for architecture and patterns. ArguSeek fetches current best practices and documentation. The agent synthesizes both into a structured context file.",
        "timing": "2-3 minutes",
        "discussion": "What would you query ChunkHound for to understand a new codebase? What external docs would ArguSeek need to fetch?",
        "context": "This applies everything from Lessons 3-5: grounding, tool use, structured execution.",
        "transition": "Let's see the exact prompt for generating AGENTS.md."
      }
    },
    {
      "type": "code",
      "title": "Generate AGENTS.md: The Prompt",
      "language": "text",
      "code": "Generate AGENTS.md for this project.\nUse the code research tool to learn the project architecture, tech stack,\nhow auth works, testing conventions, coding style, and deployment process.\nUse ArguSeek to fetch current best practices for the tech stack used and the\nlatest security guidelines.\n\nCreate a concise file (≤200 lines) with sections:\n- Tech Stack\n- Development Commands (modified for non-interactive execution)\n- Architecture (high-level structure)\n- Coding Conventions and Style\n- Critical Constraints\n- Common Pitfalls (if found).\n\nDo NOT duplicate information already in README or code comments—instead, focus\nexclusively on AI-specific operations: environment variables, non-obvious\ndependencies, and commands requiring modification for agents.",
      "caption": "Grounded prompt: codebase analysis + ecosystem research",
      "speakerNotes": {
        "talkingPoints": "This prompt demonstrates grounding from Lesson 5: ChunkHound provides codebase-specific context, ArguSeek provides current ecosystem knowledge. The sections are explicit, the constraints clear (≤200 lines, no duplication). One iteration, not weeks of manual curation.",
        "timing": "3-4 minutes",
        "discussion": "What additional sections would you add for your project? Security guidelines? API patterns? Database schema?",
        "context": "Adapt sections for your needs: Security Guidelines for sensitive data, API Patterns for microservices, Database Schema for data-intensive projects.",
        "transition": "One important caveat before we wrap up."
      }
    },
    {
      "type": "concept",
      "title": "Security: Context Files Are Attack Surfaces",
      "content": [
        "Context files inject directly into system prompts",
        "'Rules File Backdoor' attacks use Unicode/evasion",
        "Keep files minimal and version-controlled",
        "Code review context files like any other code"
      ],
      "speakerNotes": {
        "talkingPoints": "Security researchers have identified attacks where malicious instructions are injected using hidden Unicode characters or other evasion techniques. Treat context files as security-sensitive code—review them, keep them minimal, version control everything.",
        "timing": "2 minutes",
        "discussion": "Has anyone encountered prompt injection or context manipulation in the wild? What was the impact?",
        "context": "This is a real threat vector. In 2024, researchers demonstrated extracting secrets and modifying agent behavior through malicious context file injection.",
        "transition": "Let's summarize what we've learned."
      }
    },
    {
      "type": "takeaway",
      "title": "Key Takeaways",
      "content": [
        "Context files give agents project memory",
        "AGENTS.md universal, CLAUDE.md hierarchical",
        "Bootstrap context using AI tools",
        "Secure context files like code"
      ],
      "speakerNotes": {
        "talkingPoints": "Context files transform generic AI assistants into project-aware operators. Choose AGENTS.md for multi-tool teams, CLAUDE.md for advanced Claude Code features. Use agents to generate their own context, then add tribal knowledge manually. Always treat context files as security-sensitive.",
        "timing": "2 minutes",
        "discussion": "What's the first thing you'll add to your project's context file? What tribal knowledge will you codify?",
        "context": "Start with one context file, test it with a typical task, and iterate. You'll quickly discover what's missing.",
        "transition": "Next lesson: Planning & Execution—how to structure agent workflows for complex tasks."
      }
    }
  ]
}